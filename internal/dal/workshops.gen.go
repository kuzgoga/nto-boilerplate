// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"app/internal/models"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newWorkshop(db *gorm.DB, opts ...gen.DOOption) workshop {
	_workshop := workshop{}

	_workshop.workshopDo.UseDB(db, opts...)
	_workshop.workshopDo.UseModel(&models.Workshop{})

	tableName := _workshop.workshopDo.TableName()
	_workshop.ALL = field.NewAsterisk(tableName)
	_workshop.Id = field.NewUint(tableName, "id")
	_workshop.Name = field.NewString(tableName, "name")
	_workshop.WorkAreas = workshopHasManyWorkAreas{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WorkAreas", "models.WorkArea"),
		Workshop: struct {
			field.RelationField
			WorkAreas struct {
				field.RelationField
			}
			Workers struct {
				field.RelationField
				Workshop struct {
					field.RelationField
				}
				TeamTasks struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}
			}
			Tasks struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				Order struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Customer struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}
					Tasks struct {
						field.RelationField
					}
				}
				PrepTasks struct {
					field.RelationField
					Task struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}
				Workshops struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("WorkAreas.Workshop", "models.Workshop"),
			WorkAreas: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("WorkAreas.Workshop.WorkAreas", "models.WorkArea"),
			},
			Workers: struct {
				field.RelationField
				Workshop struct {
					field.RelationField
				}
				TeamTasks struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("WorkAreas.Workshop.Workers", "models.Worker"),
				Workshop: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("WorkAreas.Workshop.Workers.Workshop", "models.Workshop"),
				},
				TeamTasks: struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("WorkAreas.Workshop.Workers.TeamTasks", "models.TeamTask"),
					TeamType: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Workers.TeamTasks.TeamType", "models.TeamType"),
					},
					TeamLeader: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Workers.TeamTasks.TeamLeader", "models.Worker"),
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Workers.TeamTasks.WorkArea", "models.WorkArea"),
					},
					TeamMembers: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Workers.TeamTasks.TeamMembers", "models.Worker"),
					},
				},
			},
			Tasks: struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				Order struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Customer struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}
					Tasks struct {
						field.RelationField
					}
				}
				PrepTasks struct {
					field.RelationField
					Task struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}
				Workshops struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("WorkAreas.Workshop.Tasks", "models.Task"),
				ProductType: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.ProductType", "models.ProductType"),
				},
				Order: struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Customer struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}
					Tasks struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.Order", "models.Order"),
					ProductType: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.Order.ProductType", "models.ProductType"),
					},
					Customer: struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.Order.Customer", "models.Customer"),
						Orders: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.Order.Customer.Orders", "models.Order"),
						},
					},
					Tasks: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.Order.Tasks", "models.Task"),
					},
				},
				PrepTasks: struct {
					field.RelationField
					Task struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.PrepTasks", "models.PrepTask"),
					Task: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.PrepTasks.Task", "models.Task"),
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.PrepTasks.WorkArea", "models.WorkArea"),
					},
				},
				Workshops: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("WorkAreas.Workshop.Tasks.Workshops", "models.Workshop"),
				},
			},
		},
		PrepTasks: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WorkAreas.PrepTasks", "models.PrepTask"),
		},
		Shifts: struct {
			field.RelationField
			ProductType struct {
				field.RelationField
			}
			WorkArea struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("WorkAreas.Shifts", "models.Shift"),
			ProductType: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("WorkAreas.Shifts.ProductType", "models.ProductType"),
			},
			WorkArea: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("WorkAreas.Shifts.WorkArea", "models.WorkArea"),
			},
		},
		TeamTasks: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WorkAreas.TeamTasks", "models.TeamTask"),
		},
	}

	_workshop.Workers = workshopHasManyWorkers{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Workers", "models.Worker"),
	}

	_workshop.Tasks = workshopManyToManyTasks{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Tasks", "models.Task"),
	}

	_workshop.fillFieldMap()

	return _workshop
}

type workshop struct {
	workshopDo

	ALL       field.Asterisk
	Id        field.Uint
	Name      field.String
	WorkAreas workshopHasManyWorkAreas

	Workers workshopHasManyWorkers

	Tasks workshopManyToManyTasks

	fieldMap map[string]field.Expr
}

func (w workshop) Table(newTableName string) *workshop {
	w.workshopDo.UseTable(newTableName)
	return w.updateTableName(newTableName)
}

func (w workshop) As(alias string) *workshop {
	w.workshopDo.DO = *(w.workshopDo.As(alias).(*gen.DO))
	return w.updateTableName(alias)
}

func (w *workshop) updateTableName(table string) *workshop {
	w.ALL = field.NewAsterisk(table)
	w.Id = field.NewUint(table, "id")
	w.Name = field.NewString(table, "name")

	w.fillFieldMap()

	return w
}

func (w *workshop) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := w.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (w *workshop) fillFieldMap() {
	w.fieldMap = make(map[string]field.Expr, 5)
	w.fieldMap["id"] = w.Id
	w.fieldMap["name"] = w.Name

}

func (w workshop) clone(db *gorm.DB) workshop {
	w.workshopDo.ReplaceConnPool(db.Statement.ConnPool)
	return w
}

func (w workshop) replaceDB(db *gorm.DB) workshop {
	w.workshopDo.ReplaceDB(db)
	return w
}

type workshopHasManyWorkAreas struct {
	db *gorm.DB

	field.RelationField

	Workshop struct {
		field.RelationField
		WorkAreas struct {
			field.RelationField
		}
		Workers struct {
			field.RelationField
			Workshop struct {
				field.RelationField
			}
			TeamTasks struct {
				field.RelationField
				TeamType struct {
					field.RelationField
				}
				TeamLeader struct {
					field.RelationField
				}
				WorkArea struct {
					field.RelationField
				}
				TeamMembers struct {
					field.RelationField
				}
			}
		}
		Tasks struct {
			field.RelationField
			ProductType struct {
				field.RelationField
			}
			Order struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				Customer struct {
					field.RelationField
					Orders struct {
						field.RelationField
					}
				}
				Tasks struct {
					field.RelationField
				}
			}
			PrepTasks struct {
				field.RelationField
				Task struct {
					field.RelationField
				}
				WorkArea struct {
					field.RelationField
				}
			}
			Workshops struct {
				field.RelationField
			}
		}
	}
	PrepTasks struct {
		field.RelationField
	}
	Shifts struct {
		field.RelationField
		ProductType struct {
			field.RelationField
		}
		WorkArea struct {
			field.RelationField
		}
	}
	TeamTasks struct {
		field.RelationField
	}
}

func (a workshopHasManyWorkAreas) Where(conds ...field.Expr) *workshopHasManyWorkAreas {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a workshopHasManyWorkAreas) WithContext(ctx context.Context) *workshopHasManyWorkAreas {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a workshopHasManyWorkAreas) Session(session *gorm.Session) *workshopHasManyWorkAreas {
	a.db = a.db.Session(session)
	return &a
}

func (a workshopHasManyWorkAreas) Model(m *models.Workshop) *workshopHasManyWorkAreasTx {
	return &workshopHasManyWorkAreasTx{a.db.Model(m).Association(a.Name())}
}

type workshopHasManyWorkAreasTx struct{ tx *gorm.Association }

func (a workshopHasManyWorkAreasTx) Find() (result []*models.WorkArea, err error) {
	return result, a.tx.Find(&result)
}

func (a workshopHasManyWorkAreasTx) Append(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a workshopHasManyWorkAreasTx) Replace(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a workshopHasManyWorkAreasTx) Delete(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a workshopHasManyWorkAreasTx) Clear() error {
	return a.tx.Clear()
}

func (a workshopHasManyWorkAreasTx) Count() int64 {
	return a.tx.Count()
}

type workshopHasManyWorkers struct {
	db *gorm.DB

	field.RelationField
}

func (a workshopHasManyWorkers) Where(conds ...field.Expr) *workshopHasManyWorkers {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a workshopHasManyWorkers) WithContext(ctx context.Context) *workshopHasManyWorkers {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a workshopHasManyWorkers) Session(session *gorm.Session) *workshopHasManyWorkers {
	a.db = a.db.Session(session)
	return &a
}

func (a workshopHasManyWorkers) Model(m *models.Workshop) *workshopHasManyWorkersTx {
	return &workshopHasManyWorkersTx{a.db.Model(m).Association(a.Name())}
}

type workshopHasManyWorkersTx struct{ tx *gorm.Association }

func (a workshopHasManyWorkersTx) Find() (result []*models.Worker, err error) {
	return result, a.tx.Find(&result)
}

func (a workshopHasManyWorkersTx) Append(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a workshopHasManyWorkersTx) Replace(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a workshopHasManyWorkersTx) Delete(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a workshopHasManyWorkersTx) Clear() error {
	return a.tx.Clear()
}

func (a workshopHasManyWorkersTx) Count() int64 {
	return a.tx.Count()
}

type workshopManyToManyTasks struct {
	db *gorm.DB

	field.RelationField
}

func (a workshopManyToManyTasks) Where(conds ...field.Expr) *workshopManyToManyTasks {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a workshopManyToManyTasks) WithContext(ctx context.Context) *workshopManyToManyTasks {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a workshopManyToManyTasks) Session(session *gorm.Session) *workshopManyToManyTasks {
	a.db = a.db.Session(session)
	return &a
}

func (a workshopManyToManyTasks) Model(m *models.Workshop) *workshopManyToManyTasksTx {
	return &workshopManyToManyTasksTx{a.db.Model(m).Association(a.Name())}
}

type workshopManyToManyTasksTx struct{ tx *gorm.Association }

func (a workshopManyToManyTasksTx) Find() (result []*models.Task, err error) {
	return result, a.tx.Find(&result)
}

func (a workshopManyToManyTasksTx) Append(values ...*models.Task) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a workshopManyToManyTasksTx) Replace(values ...*models.Task) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a workshopManyToManyTasksTx) Delete(values ...*models.Task) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a workshopManyToManyTasksTx) Clear() error {
	return a.tx.Clear()
}

func (a workshopManyToManyTasksTx) Count() int64 {
	return a.tx.Count()
}

type workshopDo struct{ gen.DO }

type IWorkshopDo interface {
	gen.SubQuery
	Debug() IWorkshopDo
	WithContext(ctx context.Context) IWorkshopDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IWorkshopDo
	WriteDB() IWorkshopDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IWorkshopDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IWorkshopDo
	Not(conds ...gen.Condition) IWorkshopDo
	Or(conds ...gen.Condition) IWorkshopDo
	Select(conds ...field.Expr) IWorkshopDo
	Where(conds ...gen.Condition) IWorkshopDo
	Order(conds ...field.Expr) IWorkshopDo
	Distinct(cols ...field.Expr) IWorkshopDo
	Omit(cols ...field.Expr) IWorkshopDo
	Join(table schema.Tabler, on ...field.Expr) IWorkshopDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IWorkshopDo
	RightJoin(table schema.Tabler, on ...field.Expr) IWorkshopDo
	Group(cols ...field.Expr) IWorkshopDo
	Having(conds ...gen.Condition) IWorkshopDo
	Limit(limit int) IWorkshopDo
	Offset(offset int) IWorkshopDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IWorkshopDo
	Unscoped() IWorkshopDo
	Create(values ...*models.Workshop) error
	CreateInBatches(values []*models.Workshop, batchSize int) error
	Save(values ...*models.Workshop) error
	First() (*models.Workshop, error)
	Take() (*models.Workshop, error)
	Last() (*models.Workshop, error)
	Find() ([]*models.Workshop, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Workshop, err error)
	FindInBatches(result *[]*models.Workshop, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.Workshop) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IWorkshopDo
	Assign(attrs ...field.AssignExpr) IWorkshopDo
	Joins(fields ...field.RelationField) IWorkshopDo
	Preload(fields ...field.RelationField) IWorkshopDo
	FirstOrInit() (*models.Workshop, error)
	FirstOrCreate() (*models.Workshop, error)
	FindByPage(offset int, limit int) (result []*models.Workshop, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IWorkshopDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (w workshopDo) Debug() IWorkshopDo {
	return w.withDO(w.DO.Debug())
}

func (w workshopDo) WithContext(ctx context.Context) IWorkshopDo {
	return w.withDO(w.DO.WithContext(ctx))
}

func (w workshopDo) ReadDB() IWorkshopDo {
	return w.Clauses(dbresolver.Read)
}

func (w workshopDo) WriteDB() IWorkshopDo {
	return w.Clauses(dbresolver.Write)
}

func (w workshopDo) Session(config *gorm.Session) IWorkshopDo {
	return w.withDO(w.DO.Session(config))
}

func (w workshopDo) Clauses(conds ...clause.Expression) IWorkshopDo {
	return w.withDO(w.DO.Clauses(conds...))
}

func (w workshopDo) Returning(value interface{}, columns ...string) IWorkshopDo {
	return w.withDO(w.DO.Returning(value, columns...))
}

func (w workshopDo) Not(conds ...gen.Condition) IWorkshopDo {
	return w.withDO(w.DO.Not(conds...))
}

func (w workshopDo) Or(conds ...gen.Condition) IWorkshopDo {
	return w.withDO(w.DO.Or(conds...))
}

func (w workshopDo) Select(conds ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.Select(conds...))
}

func (w workshopDo) Where(conds ...gen.Condition) IWorkshopDo {
	return w.withDO(w.DO.Where(conds...))
}

func (w workshopDo) Order(conds ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.Order(conds...))
}

func (w workshopDo) Distinct(cols ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.Distinct(cols...))
}

func (w workshopDo) Omit(cols ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.Omit(cols...))
}

func (w workshopDo) Join(table schema.Tabler, on ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.Join(table, on...))
}

func (w workshopDo) LeftJoin(table schema.Tabler, on ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.LeftJoin(table, on...))
}

func (w workshopDo) RightJoin(table schema.Tabler, on ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.RightJoin(table, on...))
}

func (w workshopDo) Group(cols ...field.Expr) IWorkshopDo {
	return w.withDO(w.DO.Group(cols...))
}

func (w workshopDo) Having(conds ...gen.Condition) IWorkshopDo {
	return w.withDO(w.DO.Having(conds...))
}

func (w workshopDo) Limit(limit int) IWorkshopDo {
	return w.withDO(w.DO.Limit(limit))
}

func (w workshopDo) Offset(offset int) IWorkshopDo {
	return w.withDO(w.DO.Offset(offset))
}

func (w workshopDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IWorkshopDo {
	return w.withDO(w.DO.Scopes(funcs...))
}

func (w workshopDo) Unscoped() IWorkshopDo {
	return w.withDO(w.DO.Unscoped())
}

func (w workshopDo) Create(values ...*models.Workshop) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Create(values)
}

func (w workshopDo) CreateInBatches(values []*models.Workshop, batchSize int) error {
	return w.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (w workshopDo) Save(values ...*models.Workshop) error {
	if len(values) == 0 {
		return nil
	}
	return w.DO.Save(values)
}

func (w workshopDo) First() (*models.Workshop, error) {
	if result, err := w.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.Workshop), nil
	}
}

func (w workshopDo) Take() (*models.Workshop, error) {
	if result, err := w.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.Workshop), nil
	}
}

func (w workshopDo) Last() (*models.Workshop, error) {
	if result, err := w.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.Workshop), nil
	}
}

func (w workshopDo) Find() ([]*models.Workshop, error) {
	result, err := w.DO.Find()
	return result.([]*models.Workshop), err
}

func (w workshopDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Workshop, err error) {
	buf := make([]*models.Workshop, 0, batchSize)
	err = w.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (w workshopDo) FindInBatches(result *[]*models.Workshop, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return w.DO.FindInBatches(result, batchSize, fc)
}

func (w workshopDo) Attrs(attrs ...field.AssignExpr) IWorkshopDo {
	return w.withDO(w.DO.Attrs(attrs...))
}

func (w workshopDo) Assign(attrs ...field.AssignExpr) IWorkshopDo {
	return w.withDO(w.DO.Assign(attrs...))
}

func (w workshopDo) Joins(fields ...field.RelationField) IWorkshopDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Joins(_f))
	}
	return &w
}

func (w workshopDo) Preload(fields ...field.RelationField) IWorkshopDo {
	for _, _f := range fields {
		w = *w.withDO(w.DO.Preload(_f))
	}
	return &w
}

func (w workshopDo) FirstOrInit() (*models.Workshop, error) {
	if result, err := w.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.Workshop), nil
	}
}

func (w workshopDo) FirstOrCreate() (*models.Workshop, error) {
	if result, err := w.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.Workshop), nil
	}
}

func (w workshopDo) FindByPage(offset int, limit int) (result []*models.Workshop, count int64, err error) {
	result, err = w.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = w.Offset(-1).Limit(-1).Count()
	return
}

func (w workshopDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = w.Count()
	if err != nil {
		return
	}

	err = w.Offset(offset).Limit(limit).Scan(result)
	return
}

func (w workshopDo) Scan(result interface{}) (err error) {
	return w.DO.Scan(result)
}

func (w workshopDo) Delete(models ...*models.Workshop) (result gen.ResultInfo, err error) {
	return w.DO.Delete(models)
}

func (w *workshopDo) withDO(do gen.Dao) *workshopDo {
	w.DO = *do.(*gen.DO)
	return w
}
