// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"app/internal/models"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newShift(db *gorm.DB, opts ...gen.DOOption) shift {
	_shift := shift{}

	_shift.shiftDo.UseDB(db, opts...)
	_shift.shiftDo.UseModel(&models.Shift{})

	tableName := _shift.shiftDo.TableName()
	_shift.ALL = field.NewAsterisk(tableName)
	_shift.Id = field.NewUint(tableName, "id")
	_shift.Description = field.NewString(tableName, "description")
	_shift.ProductTypeId = field.NewUint(tableName, "product_type_id")
	_shift.ProductAmount = field.NewUint(tableName, "product_amount")
	_shift.ShiftDate = field.NewInt64(tableName, "shift_date")
	_shift.WorkAreaId = field.NewUint(tableName, "work_area_id")
	_shift.CreatedAt = field.NewInt64(tableName, "created_at")
	_shift.ProductType = shiftBelongsToProductType{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("ProductType", "models.ProductType"),
	}

	_shift.WorkArea = shiftBelongsToWorkArea{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WorkArea", "models.WorkArea"),
		Workshop: struct {
			field.RelationField
			WorkAreas struct {
				field.RelationField
			}
			Workers struct {
				field.RelationField
				Workshop struct {
					field.RelationField
				}
				TeamTasks struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}
			}
			Tasks struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				Order struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Customer struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}
					Tasks struct {
						field.RelationField
					}
				}
				PrepTasks struct {
					field.RelationField
					Task struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}
				Workshops struct {
					field.RelationField
				}
			}
		}{
			RelationField: field.NewRelation("WorkArea.Workshop", "models.Workshop"),
			WorkAreas: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("WorkArea.Workshop.WorkAreas", "models.WorkArea"),
			},
			Workers: struct {
				field.RelationField
				Workshop struct {
					field.RelationField
				}
				TeamTasks struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("WorkArea.Workshop.Workers", "models.Worker"),
				Workshop: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("WorkArea.Workshop.Workers.Workshop", "models.Workshop"),
				},
				TeamTasks: struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("WorkArea.Workshop.Workers.TeamTasks", "models.TeamTask"),
					TeamType: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Workers.TeamTasks.TeamType", "models.TeamType"),
					},
					TeamLeader: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Workers.TeamTasks.TeamLeader", "models.Worker"),
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Workers.TeamTasks.WorkArea", "models.WorkArea"),
					},
					TeamMembers: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Workers.TeamTasks.TeamMembers", "models.Worker"),
					},
				},
			},
			Tasks: struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				Order struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Customer struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}
					Tasks struct {
						field.RelationField
					}
				}
				PrepTasks struct {
					field.RelationField
					Task struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}
				Workshops struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("WorkArea.Workshop.Tasks", "models.Task"),
				ProductType: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("WorkArea.Workshop.Tasks.ProductType", "models.ProductType"),
				},
				Order: struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Customer struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}
					Tasks struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("WorkArea.Workshop.Tasks.Order", "models.Order"),
					ProductType: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Tasks.Order.ProductType", "models.ProductType"),
					},
					Customer: struct {
						field.RelationField
						Orders struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Tasks.Order.Customer", "models.Customer"),
						Orders: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("WorkArea.Workshop.Tasks.Order.Customer.Orders", "models.Order"),
						},
					},
					Tasks: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Tasks.Order.Tasks", "models.Task"),
					},
				},
				PrepTasks: struct {
					field.RelationField
					Task struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("WorkArea.Workshop.Tasks.PrepTasks", "models.PrepTask"),
					Task: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Tasks.PrepTasks.Task", "models.Task"),
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("WorkArea.Workshop.Tasks.PrepTasks.WorkArea", "models.WorkArea"),
					},
				},
				Workshops: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("WorkArea.Workshop.Tasks.Workshops", "models.Workshop"),
				},
			},
		},
		PrepTasks: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WorkArea.PrepTasks", "models.PrepTask"),
		},
		Shifts: struct {
			field.RelationField
			ProductType struct {
				field.RelationField
			}
			WorkArea struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("WorkArea.Shifts", "models.Shift"),
			ProductType: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("WorkArea.Shifts.ProductType", "models.ProductType"),
			},
			WorkArea: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("WorkArea.Shifts.WorkArea", "models.WorkArea"),
			},
		},
		TeamTasks: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("WorkArea.TeamTasks", "models.TeamTask"),
		},
	}

	_shift.fillFieldMap()

	return _shift
}

type shift struct {
	shiftDo

	ALL           field.Asterisk
	Id            field.Uint
	Description   field.String
	ProductTypeId field.Uint
	ProductAmount field.Uint
	ShiftDate     field.Int64
	WorkAreaId    field.Uint
	CreatedAt     field.Int64
	ProductType   shiftBelongsToProductType

	WorkArea shiftBelongsToWorkArea

	fieldMap map[string]field.Expr
}

func (s shift) Table(newTableName string) *shift {
	s.shiftDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s shift) As(alias string) *shift {
	s.shiftDo.DO = *(s.shiftDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *shift) updateTableName(table string) *shift {
	s.ALL = field.NewAsterisk(table)
	s.Id = field.NewUint(table, "id")
	s.Description = field.NewString(table, "description")
	s.ProductTypeId = field.NewUint(table, "product_type_id")
	s.ProductAmount = field.NewUint(table, "product_amount")
	s.ShiftDate = field.NewInt64(table, "shift_date")
	s.WorkAreaId = field.NewUint(table, "work_area_id")
	s.CreatedAt = field.NewInt64(table, "created_at")

	s.fillFieldMap()

	return s
}

func (s *shift) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *shift) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 9)
	s.fieldMap["id"] = s.Id
	s.fieldMap["description"] = s.Description
	s.fieldMap["product_type_id"] = s.ProductTypeId
	s.fieldMap["product_amount"] = s.ProductAmount
	s.fieldMap["shift_date"] = s.ShiftDate
	s.fieldMap["work_area_id"] = s.WorkAreaId
	s.fieldMap["created_at"] = s.CreatedAt

}

func (s shift) clone(db *gorm.DB) shift {
	s.shiftDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s shift) replaceDB(db *gorm.DB) shift {
	s.shiftDo.ReplaceDB(db)
	return s
}

type shiftBelongsToProductType struct {
	db *gorm.DB

	field.RelationField
}

func (a shiftBelongsToProductType) Where(conds ...field.Expr) *shiftBelongsToProductType {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a shiftBelongsToProductType) WithContext(ctx context.Context) *shiftBelongsToProductType {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a shiftBelongsToProductType) Session(session *gorm.Session) *shiftBelongsToProductType {
	a.db = a.db.Session(session)
	return &a
}

func (a shiftBelongsToProductType) Model(m *models.Shift) *shiftBelongsToProductTypeTx {
	return &shiftBelongsToProductTypeTx{a.db.Model(m).Association(a.Name())}
}

type shiftBelongsToProductTypeTx struct{ tx *gorm.Association }

func (a shiftBelongsToProductTypeTx) Find() (result *models.ProductType, err error) {
	return result, a.tx.Find(&result)
}

func (a shiftBelongsToProductTypeTx) Append(values ...*models.ProductType) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a shiftBelongsToProductTypeTx) Replace(values ...*models.ProductType) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a shiftBelongsToProductTypeTx) Delete(values ...*models.ProductType) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a shiftBelongsToProductTypeTx) Clear() error {
	return a.tx.Clear()
}

func (a shiftBelongsToProductTypeTx) Count() int64 {
	return a.tx.Count()
}

type shiftBelongsToWorkArea struct {
	db *gorm.DB

	field.RelationField

	Workshop struct {
		field.RelationField
		WorkAreas struct {
			field.RelationField
		}
		Workers struct {
			field.RelationField
			Workshop struct {
				field.RelationField
			}
			TeamTasks struct {
				field.RelationField
				TeamType struct {
					field.RelationField
				}
				TeamLeader struct {
					field.RelationField
				}
				WorkArea struct {
					field.RelationField
				}
				TeamMembers struct {
					field.RelationField
				}
			}
		}
		Tasks struct {
			field.RelationField
			ProductType struct {
				field.RelationField
			}
			Order struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				Customer struct {
					field.RelationField
					Orders struct {
						field.RelationField
					}
				}
				Tasks struct {
					field.RelationField
				}
			}
			PrepTasks struct {
				field.RelationField
				Task struct {
					field.RelationField
				}
				WorkArea struct {
					field.RelationField
				}
			}
			Workshops struct {
				field.RelationField
			}
		}
	}
	PrepTasks struct {
		field.RelationField
	}
	Shifts struct {
		field.RelationField
		ProductType struct {
			field.RelationField
		}
		WorkArea struct {
			field.RelationField
		}
	}
	TeamTasks struct {
		field.RelationField
	}
}

func (a shiftBelongsToWorkArea) Where(conds ...field.Expr) *shiftBelongsToWorkArea {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a shiftBelongsToWorkArea) WithContext(ctx context.Context) *shiftBelongsToWorkArea {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a shiftBelongsToWorkArea) Session(session *gorm.Session) *shiftBelongsToWorkArea {
	a.db = a.db.Session(session)
	return &a
}

func (a shiftBelongsToWorkArea) Model(m *models.Shift) *shiftBelongsToWorkAreaTx {
	return &shiftBelongsToWorkAreaTx{a.db.Model(m).Association(a.Name())}
}

type shiftBelongsToWorkAreaTx struct{ tx *gorm.Association }

func (a shiftBelongsToWorkAreaTx) Find() (result *models.WorkArea, err error) {
	return result, a.tx.Find(&result)
}

func (a shiftBelongsToWorkAreaTx) Append(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a shiftBelongsToWorkAreaTx) Replace(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a shiftBelongsToWorkAreaTx) Delete(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a shiftBelongsToWorkAreaTx) Clear() error {
	return a.tx.Clear()
}

func (a shiftBelongsToWorkAreaTx) Count() int64 {
	return a.tx.Count()
}

type shiftDo struct{ gen.DO }

type IShiftDo interface {
	gen.SubQuery
	Debug() IShiftDo
	WithContext(ctx context.Context) IShiftDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IShiftDo
	WriteDB() IShiftDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IShiftDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IShiftDo
	Not(conds ...gen.Condition) IShiftDo
	Or(conds ...gen.Condition) IShiftDo
	Select(conds ...field.Expr) IShiftDo
	Where(conds ...gen.Condition) IShiftDo
	Order(conds ...field.Expr) IShiftDo
	Distinct(cols ...field.Expr) IShiftDo
	Omit(cols ...field.Expr) IShiftDo
	Join(table schema.Tabler, on ...field.Expr) IShiftDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IShiftDo
	RightJoin(table schema.Tabler, on ...field.Expr) IShiftDo
	Group(cols ...field.Expr) IShiftDo
	Having(conds ...gen.Condition) IShiftDo
	Limit(limit int) IShiftDo
	Offset(offset int) IShiftDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IShiftDo
	Unscoped() IShiftDo
	Create(values ...*models.Shift) error
	CreateInBatches(values []*models.Shift, batchSize int) error
	Save(values ...*models.Shift) error
	First() (*models.Shift, error)
	Take() (*models.Shift, error)
	Last() (*models.Shift, error)
	Find() ([]*models.Shift, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Shift, err error)
	FindInBatches(result *[]*models.Shift, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.Shift) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IShiftDo
	Assign(attrs ...field.AssignExpr) IShiftDo
	Joins(fields ...field.RelationField) IShiftDo
	Preload(fields ...field.RelationField) IShiftDo
	FirstOrInit() (*models.Shift, error)
	FirstOrCreate() (*models.Shift, error)
	FindByPage(offset int, limit int) (result []*models.Shift, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IShiftDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s shiftDo) Debug() IShiftDo {
	return s.withDO(s.DO.Debug())
}

func (s shiftDo) WithContext(ctx context.Context) IShiftDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s shiftDo) ReadDB() IShiftDo {
	return s.Clauses(dbresolver.Read)
}

func (s shiftDo) WriteDB() IShiftDo {
	return s.Clauses(dbresolver.Write)
}

func (s shiftDo) Session(config *gorm.Session) IShiftDo {
	return s.withDO(s.DO.Session(config))
}

func (s shiftDo) Clauses(conds ...clause.Expression) IShiftDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s shiftDo) Returning(value interface{}, columns ...string) IShiftDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s shiftDo) Not(conds ...gen.Condition) IShiftDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s shiftDo) Or(conds ...gen.Condition) IShiftDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s shiftDo) Select(conds ...field.Expr) IShiftDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s shiftDo) Where(conds ...gen.Condition) IShiftDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s shiftDo) Order(conds ...field.Expr) IShiftDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s shiftDo) Distinct(cols ...field.Expr) IShiftDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s shiftDo) Omit(cols ...field.Expr) IShiftDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s shiftDo) Join(table schema.Tabler, on ...field.Expr) IShiftDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s shiftDo) LeftJoin(table schema.Tabler, on ...field.Expr) IShiftDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s shiftDo) RightJoin(table schema.Tabler, on ...field.Expr) IShiftDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s shiftDo) Group(cols ...field.Expr) IShiftDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s shiftDo) Having(conds ...gen.Condition) IShiftDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s shiftDo) Limit(limit int) IShiftDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s shiftDo) Offset(offset int) IShiftDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s shiftDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IShiftDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s shiftDo) Unscoped() IShiftDo {
	return s.withDO(s.DO.Unscoped())
}

func (s shiftDo) Create(values ...*models.Shift) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s shiftDo) CreateInBatches(values []*models.Shift, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s shiftDo) Save(values ...*models.Shift) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s shiftDo) First() (*models.Shift, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.Shift), nil
	}
}

func (s shiftDo) Take() (*models.Shift, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.Shift), nil
	}
}

func (s shiftDo) Last() (*models.Shift, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.Shift), nil
	}
}

func (s shiftDo) Find() ([]*models.Shift, error) {
	result, err := s.DO.Find()
	return result.([]*models.Shift), err
}

func (s shiftDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Shift, err error) {
	buf := make([]*models.Shift, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s shiftDo) FindInBatches(result *[]*models.Shift, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s shiftDo) Attrs(attrs ...field.AssignExpr) IShiftDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s shiftDo) Assign(attrs ...field.AssignExpr) IShiftDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s shiftDo) Joins(fields ...field.RelationField) IShiftDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s shiftDo) Preload(fields ...field.RelationField) IShiftDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s shiftDo) FirstOrInit() (*models.Shift, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.Shift), nil
	}
}

func (s shiftDo) FirstOrCreate() (*models.Shift, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.Shift), nil
	}
}

func (s shiftDo) FindByPage(offset int, limit int) (result []*models.Shift, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s shiftDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s shiftDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s shiftDo) Delete(models ...*models.Shift) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *shiftDo) withDO(do gen.Dao) *shiftDo {
	s.DO = *do.(*gen.DO)
	return s
}
