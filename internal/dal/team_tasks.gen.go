// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"app/internal/models"
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newTeamTask(db *gorm.DB, opts ...gen.DOOption) teamTask {
	_teamTask := teamTask{}

	_teamTask.teamTaskDo.UseDB(db, opts...)
	_teamTask.teamTaskDo.UseModel(&models.TeamTask{})

	tableName := _teamTask.teamTaskDo.TableName()
	_teamTask.ALL = field.NewAsterisk(tableName)
	_teamTask.Id = field.NewUint(tableName, "id")
	_teamTask.TeamTypeId = field.NewUint(tableName, "team_type_id")
	_teamTask.TeamLeaderId = field.NewUint(tableName, "team_leader_id")
	_teamTask.WorkStartDate = field.NewInt64(tableName, "work_start_date")
	_teamTask.WorkAreaId = field.NewUint(tableName, "work_area_id")
	_teamTask.ShiftDuties = field.NewString(tableName, "shift_duties")
	_teamTask.TeamType = teamTaskBelongsToTeamType{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("TeamType", "models.TeamType"),
	}

	_teamTask.TeamLeader = teamTaskBelongsToTeamLeader{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("TeamLeader", "models.Worker"),
		Workshop: struct {
			field.RelationField
			WorkAreas struct {
				field.RelationField
				Workshop struct {
					field.RelationField
				}
				PrepTasks struct {
					field.RelationField
					Task struct {
						field.RelationField
						ProductType struct {
							field.RelationField
						}
						Order struct {
							field.RelationField
							ProductType struct {
								field.RelationField
							}
							Customer struct {
								field.RelationField
								Orders struct {
									field.RelationField
								}
							}
							Tasks struct {
								field.RelationField
							}
						}
						PrepTasks struct {
							field.RelationField
						}
						Workshops struct {
							field.RelationField
						}
					}
					WorkArea struct {
						field.RelationField
					}
				}
				Shifts struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}
				TeamTasks struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}
			}
			Workers struct {
				field.RelationField
			}
			Tasks struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("TeamLeader.Workshop", "models.Workshop"),
			WorkAreas: struct {
				field.RelationField
				Workshop struct {
					field.RelationField
				}
				PrepTasks struct {
					field.RelationField
					Task struct {
						field.RelationField
						ProductType struct {
							field.RelationField
						}
						Order struct {
							field.RelationField
							ProductType struct {
								field.RelationField
							}
							Customer struct {
								field.RelationField
								Orders struct {
									field.RelationField
								}
							}
							Tasks struct {
								field.RelationField
							}
						}
						PrepTasks struct {
							field.RelationField
						}
						Workshops struct {
							field.RelationField
						}
					}
					WorkArea struct {
						field.RelationField
					}
				}
				Shifts struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}
				TeamTasks struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas", "models.WorkArea"),
				Workshop: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.Workshop", "models.Workshop"),
				},
				PrepTasks: struct {
					field.RelationField
					Task struct {
						field.RelationField
						ProductType struct {
							field.RelationField
						}
						Order struct {
							field.RelationField
							ProductType struct {
								field.RelationField
							}
							Customer struct {
								field.RelationField
								Orders struct {
									field.RelationField
								}
							}
							Tasks struct {
								field.RelationField
							}
						}
						PrepTasks struct {
							field.RelationField
						}
						Workshops struct {
							field.RelationField
						}
					}
					WorkArea struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks", "models.PrepTask"),
					Task: struct {
						field.RelationField
						ProductType struct {
							field.RelationField
						}
						Order struct {
							field.RelationField
							ProductType struct {
								field.RelationField
							}
							Customer struct {
								field.RelationField
								Orders struct {
									field.RelationField
								}
							}
							Tasks struct {
								field.RelationField
							}
						}
						PrepTasks struct {
							field.RelationField
						}
						Workshops struct {
							field.RelationField
						}
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task", "models.Task"),
						ProductType: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.ProductType", "models.ProductType"),
						},
						Order: struct {
							field.RelationField
							ProductType struct {
								field.RelationField
							}
							Customer struct {
								field.RelationField
								Orders struct {
									field.RelationField
								}
							}
							Tasks struct {
								field.RelationField
							}
						}{
							RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.Order", "models.Order"),
							ProductType: struct {
								field.RelationField
							}{
								RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.Order.ProductType", "models.ProductType"),
							},
							Customer: struct {
								field.RelationField
								Orders struct {
									field.RelationField
								}
							}{
								RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.Order.Customer", "models.Customer"),
								Orders: struct {
									field.RelationField
								}{
									RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.Order.Customer.Orders", "models.Order"),
								},
							},
							Tasks: struct {
								field.RelationField
							}{
								RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.Order.Tasks", "models.Task"),
							},
						},
						PrepTasks: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.PrepTasks", "models.PrepTask"),
						},
						Workshops: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.Task.Workshops", "models.Workshop"),
						},
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.PrepTasks.WorkArea", "models.WorkArea"),
					},
				},
				Shifts: struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.Shifts", "models.Shift"),
					ProductType: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.Shifts.ProductType", "models.ProductType"),
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.Shifts.WorkArea", "models.WorkArea"),
					},
				},
				TeamTasks: struct {
					field.RelationField
					TeamType struct {
						field.RelationField
					}
					TeamLeader struct {
						field.RelationField
					}
					WorkArea struct {
						field.RelationField
					}
					TeamMembers struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.TeamTasks", "models.TeamTask"),
					TeamType: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.TeamTasks.TeamType", "models.TeamType"),
					},
					TeamLeader: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.TeamTasks.TeamLeader", "models.Worker"),
					},
					WorkArea: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.TeamTasks.WorkArea", "models.WorkArea"),
					},
					TeamMembers: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("TeamLeader.Workshop.WorkAreas.TeamTasks.TeamMembers", "models.Worker"),
					},
				},
			},
			Workers: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("TeamLeader.Workshop.Workers", "models.Worker"),
			},
			Tasks: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("TeamLeader.Workshop.Tasks", "models.Task"),
			},
		},
		TeamTasks: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("TeamLeader.TeamTasks", "models.TeamTask"),
		},
	}

	_teamTask.WorkArea = teamTaskBelongsToWorkArea{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WorkArea", "models.WorkArea"),
	}

	_teamTask.TeamMembers = teamTaskManyToManyTeamMembers{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("TeamMembers", "models.Worker"),
	}

	_teamTask.fillFieldMap()

	return _teamTask
}

type teamTask struct {
	teamTaskDo

	ALL           field.Asterisk
	Id            field.Uint
	TeamTypeId    field.Uint
	TeamLeaderId  field.Uint
	WorkStartDate field.Int64
	WorkAreaId    field.Uint
	ShiftDuties   field.String
	TeamType      teamTaskBelongsToTeamType

	TeamLeader teamTaskBelongsToTeamLeader

	WorkArea teamTaskBelongsToWorkArea

	TeamMembers teamTaskManyToManyTeamMembers

	fieldMap map[string]field.Expr
}

func (t teamTask) Table(newTableName string) *teamTask {
	t.teamTaskDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t teamTask) As(alias string) *teamTask {
	t.teamTaskDo.DO = *(t.teamTaskDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *teamTask) updateTableName(table string) *teamTask {
	t.ALL = field.NewAsterisk(table)
	t.Id = field.NewUint(table, "id")
	t.TeamTypeId = field.NewUint(table, "team_type_id")
	t.TeamLeaderId = field.NewUint(table, "team_leader_id")
	t.WorkStartDate = field.NewInt64(table, "work_start_date")
	t.WorkAreaId = field.NewUint(table, "work_area_id")
	t.ShiftDuties = field.NewString(table, "shift_duties")

	t.fillFieldMap()

	return t
}

func (t *teamTask) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *teamTask) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 10)
	t.fieldMap["id"] = t.Id
	t.fieldMap["team_type_id"] = t.TeamTypeId
	t.fieldMap["team_leader_id"] = t.TeamLeaderId
	t.fieldMap["work_start_date"] = t.WorkStartDate
	t.fieldMap["work_area_id"] = t.WorkAreaId
	t.fieldMap["shift_duties"] = t.ShiftDuties

}

func (t teamTask) clone(db *gorm.DB) teamTask {
	t.teamTaskDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t teamTask) replaceDB(db *gorm.DB) teamTask {
	t.teamTaskDo.ReplaceDB(db)
	return t
}

type teamTaskBelongsToTeamType struct {
	db *gorm.DB

	field.RelationField
}

func (a teamTaskBelongsToTeamType) Where(conds ...field.Expr) *teamTaskBelongsToTeamType {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a teamTaskBelongsToTeamType) WithContext(ctx context.Context) *teamTaskBelongsToTeamType {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a teamTaskBelongsToTeamType) Session(session *gorm.Session) *teamTaskBelongsToTeamType {
	a.db = a.db.Session(session)
	return &a
}

func (a teamTaskBelongsToTeamType) Model(m *models.TeamTask) *teamTaskBelongsToTeamTypeTx {
	return &teamTaskBelongsToTeamTypeTx{a.db.Model(m).Association(a.Name())}
}

type teamTaskBelongsToTeamTypeTx struct{ tx *gorm.Association }

func (a teamTaskBelongsToTeamTypeTx) Find() (result *models.TeamType, err error) {
	return result, a.tx.Find(&result)
}

func (a teamTaskBelongsToTeamTypeTx) Append(values ...*models.TeamType) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a teamTaskBelongsToTeamTypeTx) Replace(values ...*models.TeamType) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a teamTaskBelongsToTeamTypeTx) Delete(values ...*models.TeamType) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a teamTaskBelongsToTeamTypeTx) Clear() error {
	return a.tx.Clear()
}

func (a teamTaskBelongsToTeamTypeTx) Count() int64 {
	return a.tx.Count()
}

type teamTaskBelongsToTeamLeader struct {
	db *gorm.DB

	field.RelationField

	Workshop struct {
		field.RelationField
		WorkAreas struct {
			field.RelationField
			Workshop struct {
				field.RelationField
			}
			PrepTasks struct {
				field.RelationField
				Task struct {
					field.RelationField
					ProductType struct {
						field.RelationField
					}
					Order struct {
						field.RelationField
						ProductType struct {
							field.RelationField
						}
						Customer struct {
							field.RelationField
							Orders struct {
								field.RelationField
							}
						}
						Tasks struct {
							field.RelationField
						}
					}
					PrepTasks struct {
						field.RelationField
					}
					Workshops struct {
						field.RelationField
					}
				}
				WorkArea struct {
					field.RelationField
				}
			}
			Shifts struct {
				field.RelationField
				ProductType struct {
					field.RelationField
				}
				WorkArea struct {
					field.RelationField
				}
			}
			TeamTasks struct {
				field.RelationField
				TeamType struct {
					field.RelationField
				}
				TeamLeader struct {
					field.RelationField
				}
				WorkArea struct {
					field.RelationField
				}
				TeamMembers struct {
					field.RelationField
				}
			}
		}
		Workers struct {
			field.RelationField
		}
		Tasks struct {
			field.RelationField
		}
	}
	TeamTasks struct {
		field.RelationField
	}
}

func (a teamTaskBelongsToTeamLeader) Where(conds ...field.Expr) *teamTaskBelongsToTeamLeader {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a teamTaskBelongsToTeamLeader) WithContext(ctx context.Context) *teamTaskBelongsToTeamLeader {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a teamTaskBelongsToTeamLeader) Session(session *gorm.Session) *teamTaskBelongsToTeamLeader {
	a.db = a.db.Session(session)
	return &a
}

func (a teamTaskBelongsToTeamLeader) Model(m *models.TeamTask) *teamTaskBelongsToTeamLeaderTx {
	return &teamTaskBelongsToTeamLeaderTx{a.db.Model(m).Association(a.Name())}
}

type teamTaskBelongsToTeamLeaderTx struct{ tx *gorm.Association }

func (a teamTaskBelongsToTeamLeaderTx) Find() (result *models.Worker, err error) {
	return result, a.tx.Find(&result)
}

func (a teamTaskBelongsToTeamLeaderTx) Append(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a teamTaskBelongsToTeamLeaderTx) Replace(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a teamTaskBelongsToTeamLeaderTx) Delete(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a teamTaskBelongsToTeamLeaderTx) Clear() error {
	return a.tx.Clear()
}

func (a teamTaskBelongsToTeamLeaderTx) Count() int64 {
	return a.tx.Count()
}

type teamTaskBelongsToWorkArea struct {
	db *gorm.DB

	field.RelationField
}

func (a teamTaskBelongsToWorkArea) Where(conds ...field.Expr) *teamTaskBelongsToWorkArea {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a teamTaskBelongsToWorkArea) WithContext(ctx context.Context) *teamTaskBelongsToWorkArea {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a teamTaskBelongsToWorkArea) Session(session *gorm.Session) *teamTaskBelongsToWorkArea {
	a.db = a.db.Session(session)
	return &a
}

func (a teamTaskBelongsToWorkArea) Model(m *models.TeamTask) *teamTaskBelongsToWorkAreaTx {
	return &teamTaskBelongsToWorkAreaTx{a.db.Model(m).Association(a.Name())}
}

type teamTaskBelongsToWorkAreaTx struct{ tx *gorm.Association }

func (a teamTaskBelongsToWorkAreaTx) Find() (result *models.WorkArea, err error) {
	return result, a.tx.Find(&result)
}

func (a teamTaskBelongsToWorkAreaTx) Append(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a teamTaskBelongsToWorkAreaTx) Replace(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a teamTaskBelongsToWorkAreaTx) Delete(values ...*models.WorkArea) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a teamTaskBelongsToWorkAreaTx) Clear() error {
	return a.tx.Clear()
}

func (a teamTaskBelongsToWorkAreaTx) Count() int64 {
	return a.tx.Count()
}

type teamTaskManyToManyTeamMembers struct {
	db *gorm.DB

	field.RelationField
}

func (a teamTaskManyToManyTeamMembers) Where(conds ...field.Expr) *teamTaskManyToManyTeamMembers {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a teamTaskManyToManyTeamMembers) WithContext(ctx context.Context) *teamTaskManyToManyTeamMembers {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a teamTaskManyToManyTeamMembers) Session(session *gorm.Session) *teamTaskManyToManyTeamMembers {
	a.db = a.db.Session(session)
	return &a
}

func (a teamTaskManyToManyTeamMembers) Model(m *models.TeamTask) *teamTaskManyToManyTeamMembersTx {
	return &teamTaskManyToManyTeamMembersTx{a.db.Model(m).Association(a.Name())}
}

type teamTaskManyToManyTeamMembersTx struct{ tx *gorm.Association }

func (a teamTaskManyToManyTeamMembersTx) Find() (result []*models.Worker, err error) {
	return result, a.tx.Find(&result)
}

func (a teamTaskManyToManyTeamMembersTx) Append(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a teamTaskManyToManyTeamMembersTx) Replace(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a teamTaskManyToManyTeamMembersTx) Delete(values ...*models.Worker) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a teamTaskManyToManyTeamMembersTx) Clear() error {
	return a.tx.Clear()
}

func (a teamTaskManyToManyTeamMembersTx) Count() int64 {
	return a.tx.Count()
}

type teamTaskDo struct{ gen.DO }

type ITeamTaskDo interface {
	gen.SubQuery
	Debug() ITeamTaskDo
	WithContext(ctx context.Context) ITeamTaskDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITeamTaskDo
	WriteDB() ITeamTaskDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITeamTaskDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITeamTaskDo
	Not(conds ...gen.Condition) ITeamTaskDo
	Or(conds ...gen.Condition) ITeamTaskDo
	Select(conds ...field.Expr) ITeamTaskDo
	Where(conds ...gen.Condition) ITeamTaskDo
	Order(conds ...field.Expr) ITeamTaskDo
	Distinct(cols ...field.Expr) ITeamTaskDo
	Omit(cols ...field.Expr) ITeamTaskDo
	Join(table schema.Tabler, on ...field.Expr) ITeamTaskDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITeamTaskDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITeamTaskDo
	Group(cols ...field.Expr) ITeamTaskDo
	Having(conds ...gen.Condition) ITeamTaskDo
	Limit(limit int) ITeamTaskDo
	Offset(offset int) ITeamTaskDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITeamTaskDo
	Unscoped() ITeamTaskDo
	Create(values ...*models.TeamTask) error
	CreateInBatches(values []*models.TeamTask, batchSize int) error
	Save(values ...*models.TeamTask) error
	First() (*models.TeamTask, error)
	Take() (*models.TeamTask, error)
	Last() (*models.TeamTask, error)
	Find() ([]*models.TeamTask, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.TeamTask, err error)
	FindInBatches(result *[]*models.TeamTask, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.TeamTask) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITeamTaskDo
	Assign(attrs ...field.AssignExpr) ITeamTaskDo
	Joins(fields ...field.RelationField) ITeamTaskDo
	Preload(fields ...field.RelationField) ITeamTaskDo
	FirstOrInit() (*models.TeamTask, error)
	FirstOrCreate() (*models.TeamTask, error)
	FindByPage(offset int, limit int) (result []*models.TeamTask, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITeamTaskDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t teamTaskDo) Debug() ITeamTaskDo {
	return t.withDO(t.DO.Debug())
}

func (t teamTaskDo) WithContext(ctx context.Context) ITeamTaskDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t teamTaskDo) ReadDB() ITeamTaskDo {
	return t.Clauses(dbresolver.Read)
}

func (t teamTaskDo) WriteDB() ITeamTaskDo {
	return t.Clauses(dbresolver.Write)
}

func (t teamTaskDo) Session(config *gorm.Session) ITeamTaskDo {
	return t.withDO(t.DO.Session(config))
}

func (t teamTaskDo) Clauses(conds ...clause.Expression) ITeamTaskDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t teamTaskDo) Returning(value interface{}, columns ...string) ITeamTaskDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t teamTaskDo) Not(conds ...gen.Condition) ITeamTaskDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t teamTaskDo) Or(conds ...gen.Condition) ITeamTaskDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t teamTaskDo) Select(conds ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t teamTaskDo) Where(conds ...gen.Condition) ITeamTaskDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t teamTaskDo) Order(conds ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t teamTaskDo) Distinct(cols ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t teamTaskDo) Omit(cols ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t teamTaskDo) Join(table schema.Tabler, on ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t teamTaskDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t teamTaskDo) RightJoin(table schema.Tabler, on ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t teamTaskDo) Group(cols ...field.Expr) ITeamTaskDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t teamTaskDo) Having(conds ...gen.Condition) ITeamTaskDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t teamTaskDo) Limit(limit int) ITeamTaskDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t teamTaskDo) Offset(offset int) ITeamTaskDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t teamTaskDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITeamTaskDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t teamTaskDo) Unscoped() ITeamTaskDo {
	return t.withDO(t.DO.Unscoped())
}

func (t teamTaskDo) Create(values ...*models.TeamTask) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t teamTaskDo) CreateInBatches(values []*models.TeamTask, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t teamTaskDo) Save(values ...*models.TeamTask) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t teamTaskDo) First() (*models.TeamTask, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.TeamTask), nil
	}
}

func (t teamTaskDo) Take() (*models.TeamTask, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.TeamTask), nil
	}
}

func (t teamTaskDo) Last() (*models.TeamTask, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.TeamTask), nil
	}
}

func (t teamTaskDo) Find() ([]*models.TeamTask, error) {
	result, err := t.DO.Find()
	return result.([]*models.TeamTask), err
}

func (t teamTaskDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.TeamTask, err error) {
	buf := make([]*models.TeamTask, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t teamTaskDo) FindInBatches(result *[]*models.TeamTask, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t teamTaskDo) Attrs(attrs ...field.AssignExpr) ITeamTaskDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t teamTaskDo) Assign(attrs ...field.AssignExpr) ITeamTaskDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t teamTaskDo) Joins(fields ...field.RelationField) ITeamTaskDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t teamTaskDo) Preload(fields ...field.RelationField) ITeamTaskDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t teamTaskDo) FirstOrInit() (*models.TeamTask, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.TeamTask), nil
	}
}

func (t teamTaskDo) FirstOrCreate() (*models.TeamTask, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.TeamTask), nil
	}
}

func (t teamTaskDo) FindByPage(offset int, limit int) (result []*models.TeamTask, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t teamTaskDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t teamTaskDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t teamTaskDo) Delete(models ...*models.TeamTask) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *teamTaskDo) withDO(do gen.Dao) *teamTaskDo {
	t.DO = *do.(*gen.DO)
	return t
}
